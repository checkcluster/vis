{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/ytaek.kim/dev/snc_vis/src/components/Explorer.js\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useRef } from 'react';\nimport * as d3 from 'd3';\nimport { precisionPrefix } from 'd3';\nimport inside from 'point-in-polygon';\n\nconst Explorer = props => {\n  _s();\n\n  let jsonFileName = props.dataset + \"_\" + props.method;\n  console.log(\"//\", \"../json/\" + jsonFileName + \"_points.json\");\n\n  let test = require(\"../json/mnist_sampled_2_tsne_points.json\");\n\n  let pointsData = require(\"../json/\" + jsonFileName + \"_points.json\");\n\n  let edgesData = require(\"../json/\" + jsonFileName + \"_edges.json\");\n\n  let missingPointsData = require(\"../json/\" + jsonFileName + \"_missing_points.json\");\n\n  console.log(edgesData);\n  pointsData = pointsData.map((d, i) => {\n    return {\n      coor: d.coor,\n      label: d.label,\n      idx: i\n    };\n  });\n  let knnData = edgesData.reduce(function (acc, val) {\n    if (val.start in acc) acc[val.start].push(val.end);else acc[val.start] = [val.end];\n    if (val.end in acc) acc[val.end].push(val.start);else acc[val.end] = [val.start];\n    return acc;\n  }, {});\n  console.log(pointsData, edgesData, missingPointsData, knnData);\n  const width = 1000;\n  const height = 1000;\n  const margin = {\n    hor: width / 20,\n    ver: height / 20\n  };\n  const [minX, maxX] = d3.extent(pointsData, d => d.coor[0]);\n  const [minY, maxY] = d3.extent(pointsData, d => d.coor[1]);\n  const xScale = d3.scaleLinear().domain([minX, maxX]).range([0, width]);\n  const yScale = d3.scaleLinear().domain([minY, maxY]).range([0, height]);\n  let svgs, svg, svgPoints, svgEdges, svgMissingEdges, svgContour, svgContourPoints;\n  let pointSelection;\n  const radius = props.radius;\n  const strokeWidth = props.stroke;\n  let colorScale = d3.scaleOrdinal(d3.schemeCategory10);\n  const isSelecting = useRef(false);\n  const isMakingContour = useRef(false);\n  const contour = useRef([]);\n\n  function pointsInPolygon(polygon) {\n    polygon = polygon.map(d => [xScale.invert(d[0] - margin.hor), yScale.invert(d[1] - margin.ver)]);\n    let pointsInPolygon = pointsData.reduce(function (acc, val, i) {\n      if (inside(val.coor, polygon)) acc.push(i);\n      return acc;\n    }, []);\n    return pointsInPolygon;\n  }\n\n  function getMissingEdgesInfo(missingPointsDict) {\n    let missingPointsList = Object.keys(missingPointsDict);\n    let edges = missingPointsList.reduce(function (acc, val) {\n      let adjacentPoints = knnData[val.toString()];\n      if (adjacentPoints === undefined) return acc;\n      adjacentPoints.forEach(adjacentPoint => {\n        if (parseInt(adjacentPoint) in missingPointsDict) {\n          let keyStr = parseInt(adjacentPoint) < val ? adjacentPoint + \"_\" + val.toString() : val.toString() + \"_\" + adjacentPoint;\n          acc.push(keyStr);\n        }\n      });\n      return acc;\n    }, []);\n    edges = Array.from(new Set(edges));\n    edges = edges.map(d => {\n      const incidentPoints = d.split(\"_\");\n      return [parseInt(incidentPoints[0]), parseInt(incidentPoints[1])];\n    });\n    return edges;\n  }\n\n  useEffect(() => {\n    svgs = d3.select(\"#scatterplot\" + props.dataset + props.method).attr(\"width\", width + margin.hor * 2).attr(\"height\", height + margin.ver * 2);\n    svg = svgs.append(\"g\").attr(\"id\", \"scatterplot_g\" + props.dataset + props.method).attr(\"transform\", \"translate(\" + margin.hor + \", \" + margin.ver + \")\");\n    svgEdges = svg.append(\"g\").attr(\"id\", \"edge_g\" + props.dataset + props.method);\n    svgContour = svg.append(\"g\").attr(\"id\", \"contour_g\" + props.dataset + props.method);\n    svgContourPoints = svg.append(\"g\").attr(\"id\", \"contour_point_g\" + props.dataset + props.method);\n\n    function renderMissingEdges(edges, missingPointsDict) {\n      svgMissingEdges.selectAll(\"path\").data(edges).enter().append(\"path\").attr(\"fill\", \"none\").attr(\"stroke-width\", strokeWidth).attr(\"stroke\", \"red\").attr(\"d\", d => {\n        return d3.line().x(datum => xScale(pointsData[datum].coor[0])).y(datum => yScale(pointsData[datum].coor[1]))(d);\n      }).style(\"opacity\", d => {\n        return (missingPointsDict[d[0]] + missingPointsDict[d[1]]) / 2;\n      });\n    }\n\n    pointSelection = svg.append(\"rect\").attr(\"width\", width + margin.hor * 2).attr(\"height\", height + margin.ver * 2).attr(\"transform\", \"translate(-\" + margin.hor + \", -\" + margin.ver + \")\").style(\"fill-opacity\", 0).style(\"stroke\", \"black\").style(\"stroke-width\", 2).on(\"click\", function (event) {\n      if (!isSelecting.current) {\n        if (!isMakingContour.current) {\n          isMakingContour.current = true;\n          contour.current.push([event.offsetX, event.offsetY]);\n          svgContour.append(\"path\").attr(\"id\", \"current_path\").attr(\"fill\", \"none\").attr(\"stroke\", \"blue\").attr(\"storke-width\", 1).attr(\"stroke-dasharray\", \"2 \");\n        } else {\n          svgContour.select(\"#current_path\").attr(\"id\", \"\").attr(\"d\", () => {\n            let start, end;\n\n            if (Math.abs(event.offsetX - contour.current[0][0]) < 4 && Math.abs(event.offsetY - contour.current[0][1]) < 4) {\n              start = contour.current[contour.current.length - 1];\n              end = contour.current[0];\n              isSelecting.current = true;\n              isMakingContour.current = false; // finish making contour\n            } else {\n              contour.current.push([event.offsetX, event.offsetY]);\n              start = contour.current[contour.current.length - 2];\n              end = contour.current[contour.current.length - 1];\n              svgContour.append(\"path\").attr(\"id\", \"current_path\").attr(\"fill\", \"none\").attr(\"stroke\", \"blue\").attr(\"storke-width\", 1).attr(\"stroke-dasharray\", \"2 \");\n            }\n\n            return d3.line().x(datum => datum[0]).y(datum => datum[1])([[start[0] - margin.hor, start[1] - margin.ver], [end[0] - margin.hor, end[1] - margin.ver]]);\n          });\n\n          if (isSelecting.current) {\n            let points = pointsInPolygon(contour.current);\n            svgContourPoints.selectAll(\"circle\").data(points).enter().append(\"circle\").attr(\"r\", radius * 2).attr(\"cx\", d => xScale(pointsData[d].coor[0])).attr(\"cy\", d => yScale(pointsData[d].coor[1])).attr(\"fill\", \"blue\");\n            let missingPointsDict = points.reduce(function (acc, val) {\n              let currentDict = missingPointsData[val];\n              Object.keys(currentDict).forEach(key => {\n                if (key in acc) acc[key] += currentDict[key];else acc[key] = currentDict[key];\n              });\n              return acc;\n            }, {});\n            let listLen = points.length;\n            Object.keys(missingPointsDict).forEach(d => {\n              missingPointsDict[d] /= listLen;\n            });\n            let edges = getMissingEdgesInfo(missingPointsDict);\n            renderMissingEdges(edges, missingPointsDict);\n          }\n        }\n\n        if (isMakingContour.current) {\n          svgContour.append(\"circle\").attr(\"r\", 1.5).attr(\"cx\", event.offsetX - margin.hor).attr(\"cy\", event.offsetY - margin.ver).attr(\"fill\", \"none\").attr(\"stroke\", \"blue\").attr(\"stroke-width\", 1);\n        }\n      } else {\n        isSelecting.current = false;\n        contour.current = [];\n        svgContour.selectAll(\"path\").remove();\n        svgContour.selectAll(\"circle\").remove();\n        svgContourPoints.selectAll(\"circle\").remove();\n        svgMissingEdges.selectAll(\"path\").remove();\n      }\n    }).on(\"mousemove\", function (event) {\n      // console.log(event)\n      svgContour.select(\"#current_path\").attr(\"d\", () => {\n        let start = contour.current[contour.current.length - 1];\n        let end;\n        if (Math.abs(event.offsetX - contour.current[0][0]) < 4 && Math.abs(event.offsetY - contour.current[0][1]) < 4) end = contour.current[0];else end = [event.offsetX, event.offsetY];\n        return d3.line().x(datum => datum[0]).y(datum => datum[1])([[start[0] - margin.hor, start[1] - margin.ver], [end[0] - margin.hor, end[1] - margin.ver]]);\n      });\n    });\n    svgPoints = svg.append(\"g\").attr(\"id\", \"circle_g\" + props.dataset + props.method);\n    svgMissingEdges = svg.append(\"g\").attr(\"id\", \"missing_edge_g\" + props.dataset + props.method); // points\n\n    svgPoints.selectAll(\"circle\").data(pointsData).join(enter => {\n      enter.append(\"circle\").attr(\"class\", (d, i) => \"circle\" + i.toString()).attr(\"fill\", d => {\n        if (props.isLabel) return colorScale(d.label);else return \"black\";\n      }).attr(\"cx\", d => xScale(d.coor[0])).attr(\"cy\", d => yScale(d.coor[1])).style(\"opacity\", 0.8).attr(\"r\", radius); //  .on(\"mouseenter\", function() {\n      //      if(!isSelecting.current && !isMakingContour.current)\n      //         d3.select(this).attr(\"r\", radius * 3)\n      //  })\n      //  .on(\"mouseleave\", function() {\n      //      if(!isSelecting.current && !isMakingContour.current)\n      //         d3.select(this).attr(\"r\", radius)\n      //  })\n      //  .on(\"click\", function(e, d) {\n      //      if(!isSelecting.current && !isMakingContour.current){\n      //         isSelecting.current = true;\n      //         d3.select(this).attr(\"r\", radius * 5);\n      //         let missingPointsDict = missingPointsData[d.idx];\n      //         let edges = getMissingEdgesInfo(missingPointsDict)\n      //         renderMissingEdges(edges, missingPointsDict);\n      //      }\n      //  });\n    }); // edges\n\n    function scaleBivariate(first, second) {\n      let lScale = d3.scaleLinear().domain([0, 2]).range([100, 30]);\n      let aScale = d3.scaleLinear().domain([1, -1]).range([30, -30]);\n      let bScale = d3.scaleLinear().domain([1, -1]).range([20, -20]);\n      return d3.color(d3.lab(lScale(first + second), aScale(first - second), bScale(second - first)));\n    }\n\n    svgEdges.selectAll(\"path\").data(edgesData).join(enter => {\n      enter.append(\"path\").attr(\"fill\", \"none\").attr(\"stroke-width\", strokeWidth).attr(\"opacity\", d => {\n        if (props.showMissing && !props.showFalse) return d.missing_val;\n        if (!props.showMissing && props.showFalse) return d.false_val;\n        if (props.showMissing && props.showFalse) return 1;\n      }).attr(\"stroke\", d => {\n        if (props.showMissing && props.showFalse) return scaleBivariate(d.false_val, d.missing_val);else return \"black\";\n      }).attr(\"d\", d => {\n        return d3.line().x(datum => xScale(pointsData[datum].coor[0])).y(datum => yScale(pointsData[datum].coor[1]))([d.start, d.end]);\n      });\n    });\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"svg\", {\n      id: \"scatterplot\" + props.dataset + props.method\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 348,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 347,\n    columnNumber: 9\n  }, this);\n};\n\n_s(Explorer, \"QPIAxZHNG24cG3FWmzaT1KLlkOY=\");\n\n_c = Explorer;\nexport default Explorer;\n\nvar _c;\n\n$RefreshReg$(_c, \"Explorer\");","map":{"version":3,"sources":["/Users/ytaek.kim/dev/snc_vis/src/components/Explorer.js"],"names":["React","useEffect","useRef","d3","precisionPrefix","inside","Explorer","props","jsonFileName","dataset","method","console","log","test","require","pointsData","edgesData","missingPointsData","map","d","i","coor","label","idx","knnData","reduce","acc","val","start","push","end","width","height","margin","hor","ver","minX","maxX","extent","minY","maxY","xScale","scaleLinear","domain","range","yScale","svgs","svg","svgPoints","svgEdges","svgMissingEdges","svgContour","svgContourPoints","pointSelection","radius","strokeWidth","stroke","colorScale","scaleOrdinal","schemeCategory10","isSelecting","isMakingContour","contour","pointsInPolygon","polygon","invert","getMissingEdgesInfo","missingPointsDict","missingPointsList","Object","keys","edges","adjacentPoints","toString","undefined","forEach","adjacentPoint","parseInt","keyStr","Array","from","Set","incidentPoints","split","select","attr","append","renderMissingEdges","selectAll","data","enter","line","x","datum","y","style","on","event","current","offsetX","offsetY","Math","abs","length","points","currentDict","key","listLen","remove","join","isLabel","scaleBivariate","first","second","lScale","aScale","bScale","color","lab","showMissing","showFalse","missing_val","false_val"],"mappings":"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","sourcesContent":["import React, { useEffect, useRef } from 'react';\r\nimport * as d3 from 'd3';\r\nimport { precisionPrefix } from 'd3';\r\nimport inside from 'point-in-polygon'\r\n\r\nconst Explorer = (props) => {\r\n\r\n\r\n    let jsonFileName = props.dataset + \"_\" + props.method;\r\nconsole.log(\"//\", \"../json/\" + jsonFileName + \"_points.json\");\r\nlet test = require(\"../json/mnist_sampled_2_tsne_points.json\");\r\n    let pointsData = require(\"../json/\" + jsonFileName + \"_points.json\");\r\n    let edgesData = require(\"../json/\" + jsonFileName + \"_edges.json\");\r\n    let missingPointsData = require(\"../json/\" + jsonFileName + \"_missing_points.json\")\r\n\r\n\r\n    console.log(edgesData)\r\n\r\n    pointsData = pointsData.map((d, i) => {\r\n        return {\r\n            coor: d.coor,\r\n            label: d.label,\r\n            idx: i\r\n        };\r\n    });\r\n\r\n    let knnData = edgesData.reduce(function(acc, val) {\r\n        if (val.start in acc) acc[val.start].push(val.end);\r\n        else                  acc[val.start] = [val.end];\r\n        if (val.end in acc)   acc[val.end].push(val.start);\r\n        else                  acc[val.end] = [val.start];\r\n        return acc;\r\n    }, {})\r\n\r\n    console.log(pointsData, edgesData, missingPointsData, knnData) \r\n\r\n    const width = 1000;\r\n    const height = 1000;\r\n    const margin = { hor: width / 20, ver: height / 20 };\r\n\r\n    const [minX, maxX] = d3.extent(pointsData, d => d.coor[0]);\r\n    const [minY, maxY] = d3.extent(pointsData, d => d.coor[1]);\r\n\r\n    const xScale = d3.scaleLinear()\r\n                        .domain([minX, maxX])\r\n                        .range([0, width]);\r\n    \r\n    const yScale = d3.scaleLinear()\r\n                        .domain([minY, maxY])\r\n                        .range([0, height]);\r\n\r\n\r\n    let svgs, svg, svgPoints, svgEdges, svgMissingEdges, svgContour, svgContourPoints;\r\n    let pointSelection;\r\n\r\n    const radius = props.radius;\r\n    const strokeWidth = props.stroke;\r\n\r\n\r\n    let colorScale = d3.scaleOrdinal(d3.schemeCategory10);\r\n\r\n\r\n    const isSelecting = useRef(false);\r\n    const isMakingContour = useRef(false);\r\n    const contour = useRef([]);\r\n\r\n\r\n    function pointsInPolygon(polygon) {\r\n        polygon = polygon.map(d => [xScale.invert(d[0] - margin.hor), yScale.invert(d[1] - margin.ver)]);\r\n        let pointsInPolygon = pointsData.reduce(function(acc, val, i){\r\n            if (inside(val.coor, polygon)) acc.push(i);\r\n            return acc;\r\n        }, []);\r\n        return pointsInPolygon;\r\n    }\r\n\r\n    function getMissingEdgesInfo(missingPointsDict) {\r\n        let missingPointsList = Object.keys(missingPointsDict);\r\n        let edges = missingPointsList.reduce(function(acc, val) {\r\n            let adjacentPoints = knnData[val.toString()]\r\n            if (adjacentPoints === undefined) return acc;\r\n            adjacentPoints.forEach(adjacentPoint => {\r\n                if(parseInt(adjacentPoint) in missingPointsDict) {\r\n                    let keyStr = parseInt(adjacentPoint) < val ? \r\n                                adjacentPoint  + \"_\" + val.toString() : \r\n                                val.toString() + \"_\" + adjacentPoint;\r\n                    acc.push(keyStr);\r\n                }\r\n            });\r\n            return acc;\r\n        }, []);\r\n        edges = Array.from(new Set(edges));\r\n        edges = edges.map(d => {\r\n            const incidentPoints = d.split(\"_\");\r\n            return [parseInt(incidentPoints[0]), parseInt(incidentPoints[1])];\r\n        })\r\n        return edges;\r\n    }\r\n\r\n    useEffect(() => {\r\n\r\n\r\n        svgs = d3.select(\"#scatterplot\" + props.dataset + props.method)\r\n                .attr(\"width\", width + margin.hor * 2)\r\n                .attr(\"height\", height + margin.ver * 2)\r\n     \r\n        \r\n        svg = svgs.append(\"g\")\r\n                  .attr(\"id\", \"scatterplot_g\" + props.dataset + props.method)\r\n                  .attr(\"transform\", \"translate(\" + margin.hor + \", \" + margin.ver + \")\");\r\n\r\n\r\n        svgEdges = svg.append(\"g\")\r\n                      .attr(\"id\", \"edge_g\" + props.dataset + props.method);\r\n\r\n        \r\n        svgContour = svg.append(\"g\")\r\n                      .attr(\"id\", \"contour_g\" + props.dataset + props.method);\r\n\r\n        svgContourPoints = svg.append(\"g\")\r\n                              .attr(\"id\", \"contour_point_g\" + props.dataset + props.method);\r\n\r\n\r\n        function renderMissingEdges(edges, missingPointsDict) {\r\n            svgMissingEdges.selectAll(\"path\")\r\n                          .data(edges)\r\n                          .enter()\r\n                          .append(\"path\")\r\n                          .attr(\"fill\", \"none\")\r\n                          .attr(\"stroke-width\", strokeWidth)\r\n                          .attr(\"stroke\", \"red\")\r\n                          .attr(\"d\", d => {\r\n                              return d3.line()\r\n                                      .x(datum => xScale(pointsData[datum].coor[0]))\r\n                                      .y(datum => yScale(pointsData[datum].coor[1]))\r\n                                      (d);\r\n                          })\r\n                          .style(\"opacity\", d => {\r\n                              return (missingPointsDict[d[0]] + missingPointsDict[d[1]]) / 2\r\n                          });\r\n        }\r\n\r\n\r\n        pointSelection = svg.append(\"rect\")\r\n                            .attr(\"width\", width + margin.hor * 2)\r\n                            .attr(\"height\", height  + margin.ver * 2)\r\n                            .attr(\"transform\", \"translate(-\" + margin.hor + \", -\" + margin.ver + \")\")\r\n                            .style(\"fill-opacity\", 0)\r\n                            .style(\"stroke\", \"black\")\r\n                            .style(\"stroke-width\", 2)\r\n                            .on(\"click\", function(event) {\r\n                              if(!isSelecting.current) {\r\n                                    \r\n                                  if(!isMakingContour.current) {\r\n                                      isMakingContour.current = true;\r\n                                      contour.current.push([event.offsetX, event.offsetY])\r\n                                      svgContour.append(\"path\")\r\n                                                .attr(\"id\", \"current_path\")\r\n                                                .attr(\"fill\", \"none\")\r\n                                                .attr(\"stroke\", \"blue\")\r\n                                                .attr(\"storke-width\", 1)\r\n                                                .attr(\"stroke-dasharray\", \"2 \");\r\n                                  }\r\n                                  else {\r\n                                      svgContour.select(\"#current_path\")\r\n                                                .attr(\"id\", \"\")\r\n                                                .attr(\"d\", () => {\r\n                                                    let start, end;\r\n                                                    if (Math.abs(event.offsetX - contour.current[0][0]) < 4 &&\r\n                                                        Math.abs(event.offsetY - contour.current[0][1]) < 4) {\r\n                                                            start = contour.current[contour.current.length - 1];\r\n                                                            end = contour.current[0];\r\n                                                            isSelecting.current = true;\r\n                                                            isMakingContour.current = false; // finish making contour\r\n                                                        }\r\n                                                    else {\r\n                                                        contour.current.push([event.offsetX, event.offsetY])\r\n                                                        start = contour.current[contour.current.length - 2];\r\n                                                        end = contour.current[contour.current.length - 1];\r\n                                                        svgContour.append(\"path\")\r\n                                                                  .attr(\"id\", \"current_path\")\r\n                                                                  .attr(\"fill\", \"none\")\r\n                                                                  .attr(\"stroke\", \"blue\")\r\n                                                                  .attr(\"storke-width\", 1)\r\n                                                                  .attr(\"stroke-dasharray\", \"2 \");\r\n                                                    }\r\n                                                    \r\n                                                    return d3.line()\r\n                                                             .x(datum => datum[0])\r\n                                                             .y(datum => datum[1])\r\n                                                             ([[start[0] - margin.hor, start[1] - margin.ver],[end[0] - margin.hor, end[1] - margin.ver]])\r\n                                                })\r\n                                      \r\n\r\n                                      if(isSelecting.current) {\r\n                                          let points = pointsInPolygon(contour.current);\r\n                                          svgContourPoints.selectAll(\"circle\")\r\n                                                    .data(points)\r\n                                                    .enter()\r\n                                                    .append(\"circle\")\r\n                                                    .attr(\"r\", radius * 2)\r\n                                                    .attr(\"cx\", d => xScale(pointsData[d].coor[0]))\r\n                                                    .attr(\"cy\", d => yScale(pointsData[d].coor[1]))\r\n                                                    .attr(\"fill\", \"blue\");\r\n                                        \r\n                                          let missingPointsDict = points.reduce(function(acc, val) {\r\n                                              let currentDict = missingPointsData[val];\r\n                                              Object.keys(currentDict).forEach(key => {\r\n                                                  if (key in acc) acc[key] += currentDict[key];\r\n                                                  else            acc[key] =  currentDict[key];\r\n                                              });\r\n                                              return acc;\r\n                                          }, {})\r\n\r\n                                          let listLen = points.length;\r\n                                          Object.keys(missingPointsDict).forEach(d => {\r\n                                              missingPointsDict[d] /= listLen;\r\n                                          })\r\n                                          let edges = getMissingEdgesInfo(missingPointsDict);\r\n                                          renderMissingEdges(edges, missingPointsDict);\r\n                                      }\r\n                                      \r\n                                  }\r\n                                  if(isMakingContour.current){\r\n                                      svgContour.append(\"circle\")\r\n                                                .attr(\"r\", 1.5)\r\n                                                .attr(\"cx\", event.offsetX - margin.hor)\r\n                                                .attr(\"cy\", event.offsetY - margin.ver)\r\n                                                .attr(\"fill\", \"none\")\r\n                                                .attr(\"stroke\", \"blue\")\r\n                                                .attr(\"stroke-width\", 1);\r\n                                  }\r\n                              }\r\n                              else {\r\n                                  isSelecting.current = false;\r\n                                  contour.current = [];\r\n                                  svgContour.selectAll(\"path\").remove();\r\n                                  svgContour.selectAll(\"circle\").remove();\r\n                                  svgContourPoints.selectAll(\"circle\").remove();\r\n                                  svgMissingEdges.selectAll(\"path\").remove();\r\n                              }\r\n                            })\r\n                            .on(\"mousemove\", function(event) {\r\n                                // console.log(event)\r\n                                svgContour.select(\"#current_path\")\r\n                                          .attr(\"d\",() =>{\r\n                                              let start = contour.current[contour.current.length - 1]\r\n                                              let end;\r\n                                              if (Math.abs(event.offsetX - contour.current[0][0]) < 4 &&\r\n                                                  Math.abs(event.offsetY - contour.current[0][1]) < 4) \r\n                                                  end = contour.current[0];\r\n                                              else end = [event.offsetX, event.offsetY]\r\n                                              return d3.line()\r\n                                                       .x(datum => datum[0])\r\n                                                       .y(datum => datum[1])\r\n                                                       ([[start[0] - margin.hor, start[1] - margin.ver],[end[0] - margin.hor, end[1] - margin.ver]])\r\n\r\n                                          })\r\n                                \r\n                            })\r\n \r\n        \r\n\r\n\r\n        svgPoints = svg.append(\"g\")\r\n                    .attr(\"id\", \"circle_g\" + props.dataset + props.method);\r\n        \r\n        svgMissingEdges = svg.append(\"g\")\r\n                             .attr(\"id\", \"missing_edge_g\" + props.dataset + props.method);\r\n        \r\n\r\n        // points\r\n        svgPoints.selectAll(\"circle\")\r\n                         .data(pointsData)\r\n                         .join(\r\n                             enter => {\r\n                                 enter.append(\"circle\")\r\n                                     .attr(\"class\", (d,i) => \"circle\" + i.toString())\r\n                                     .attr(\"fill\", d => {\r\n                                         if (props.isLabel) return colorScale(d.label);\r\n                                         else return \"black\"; \r\n                                     })\r\n                                     .attr(\"cx\", d => xScale(d.coor[0]))\r\n                                     .attr(\"cy\", d => yScale(d.coor[1]))\r\n                                     .style(\"opacity\", 0.8)\r\n                                     .attr(\"r\", radius)\r\n                                    //  .on(\"mouseenter\", function() {\r\n                                    //      if(!isSelecting.current && !isMakingContour.current)\r\n                                    //         d3.select(this).attr(\"r\", radius * 3)\r\n                                    //  })\r\n                                    //  .on(\"mouseleave\", function() {\r\n                                    //      if(!isSelecting.current && !isMakingContour.current)\r\n                                    //         d3.select(this).attr(\"r\", radius)\r\n                                    //  })\r\n                                    //  .on(\"click\", function(e, d) {\r\n                                    //      if(!isSelecting.current && !isMakingContour.current){\r\n                                    //         isSelecting.current = true;\r\n                                    //         d3.select(this).attr(\"r\", radius * 5);\r\n                                    //         let missingPointsDict = missingPointsData[d.idx];\r\n                                    //         let edges = getMissingEdgesInfo(missingPointsDict)\r\n                                    //         renderMissingEdges(edges, missingPointsDict);\r\n                                    //      }\r\n                                    //  });\r\n                             }\r\n                         );\r\n        \r\n        // edges\r\n\r\n        function scaleBivariate(first, second) {\r\n            let lScale = d3.scaleLinear().domain([0, 2]).range([100, 30])\r\n            let aScale = d3.scaleLinear().domain([1, -1]).range([30, -30])\r\n            let bScale = d3.scaleLinear().domain([1, -1]).range([20, -20])\r\n\r\n            return d3.color(d3.lab(lScale(first + second), aScale(first - second), bScale(second-first)))\r\n        }\r\n\r\n\r\n        svgEdges.selectAll(\"path\")\r\n                .data(edgesData)\r\n                .join(\r\n                    enter => {\r\n                        enter.append(\"path\")\r\n                             .attr(\"fill\", \"none\")\r\n                             .attr(\"stroke-width\", strokeWidth)\r\n                             .attr(\"opacity\", d => {\r\n                                 if ( props.showMissing && !props.showFalse) return d.missing_val;\r\n                                 if (!props.showMissing &&  props.showFalse) return d.false_val;\r\n                                 if ( props.showMissing &&  props.showFalse) return 1;\r\n                             })\r\n                             .attr(\"stroke\", d => {\r\n                                 if (props.showMissing && props.showFalse) return scaleBivariate(d.false_val, d.missing_val);\r\n                                 else return \"black\";\r\n                             })\r\n                             .attr(\"d\", d => {\r\n                                return d3.line()\r\n                                         .x(datum => xScale(pointsData[datum].coor[0]))\r\n                                         .y(datum => yScale(pointsData[datum].coor[1]))\r\n                                         ([d.start, d.end])\r\n                             });\r\n                    }\r\n                )\r\n    }, []);\r\n   \r\n\r\n\r\n    return (\r\n        <div>\r\n            <svg id={\"scatterplot\" + props.dataset + props.method}></svg>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Explorer;"]},"metadata":{},"sourceType":"module"}